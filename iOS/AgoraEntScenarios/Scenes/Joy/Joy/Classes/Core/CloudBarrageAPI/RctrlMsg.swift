// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: RctrlMsg.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Agora_Pb_Rctrl_MsgType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownType // = 0
  case mouseEventType // = 1001
  case keyboardEventType // = 1002
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1001: self = .mouseEventType
    case 1002: self = .keyboardEventType
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .mouseEventType: return 1001
    case .keyboardEventType: return 1002
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Agora_Pb_Rctrl_MsgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Agora_Pb_Rctrl_MsgType] = [
    .unknownType,
    .mouseEventType,
    .keyboardEventType,
  ]
}

#endif  // swift(>=4.2)

enum Agora_Pb_Rctrl_MouseEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mouseEventUnknown // = 0
  case mouseEventMove // = 1
  case mouseEventLbuttonDown // = 2
  case mouseEventLbuttonUp // = 3
  case mouseEventRbuttonDown // = 4
  case mouseEventRbuttonUp // = 5
  case mouseEventMbuttonDown // = 6
  case mouseEventMbuttonUp // = 7
  case mouseEventWheel // = 8
  case mouseEventXbuttonDown // = 9
  case mouseEventXbuttonUp // = 10
  case mouseEventHwheel // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .mouseEventUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mouseEventUnknown
    case 1: self = .mouseEventMove
    case 2: self = .mouseEventLbuttonDown
    case 3: self = .mouseEventLbuttonUp
    case 4: self = .mouseEventRbuttonDown
    case 5: self = .mouseEventRbuttonUp
    case 6: self = .mouseEventMbuttonDown
    case 7: self = .mouseEventMbuttonUp
    case 8: self = .mouseEventWheel
    case 9: self = .mouseEventXbuttonDown
    case 10: self = .mouseEventXbuttonUp
    case 11: self = .mouseEventHwheel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mouseEventUnknown: return 0
    case .mouseEventMove: return 1
    case .mouseEventLbuttonDown: return 2
    case .mouseEventLbuttonUp: return 3
    case .mouseEventRbuttonDown: return 4
    case .mouseEventRbuttonUp: return 5
    case .mouseEventMbuttonDown: return 6
    case .mouseEventMbuttonUp: return 7
    case .mouseEventWheel: return 8
    case .mouseEventXbuttonDown: return 9
    case .mouseEventXbuttonUp: return 10
    case .mouseEventHwheel: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Agora_Pb_Rctrl_MouseEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Agora_Pb_Rctrl_MouseEventType] = [
    .mouseEventUnknown,
    .mouseEventMove,
    .mouseEventLbuttonDown,
    .mouseEventLbuttonUp,
    .mouseEventRbuttonDown,
    .mouseEventRbuttonUp,
    .mouseEventMbuttonDown,
    .mouseEventMbuttonUp,
    .mouseEventWheel,
    .mouseEventXbuttonDown,
    .mouseEventXbuttonUp,
    .mouseEventHwheel,
  ]
}

#endif  // swift(>=4.2)

enum Agora_Pb_Rctrl_MouseEventFlag: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case lbutton // = 1
  case rbutton // = 2
  case shift // = 4
  case control // = 8
  case mbutton // = 16
  case xbutton1 // = 32
  case xbutton2 // = 64
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .lbutton
    case 2: self = .rbutton
    case 4: self = .shift
    case 8: self = .control
    case 16: self = .mbutton
    case 32: self = .xbutton1
    case 64: self = .xbutton2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .lbutton: return 1
    case .rbutton: return 2
    case .shift: return 4
    case .control: return 8
    case .mbutton: return 16
    case .xbutton1: return 32
    case .xbutton2: return 64
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Agora_Pb_Rctrl_MouseEventFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Agora_Pb_Rctrl_MouseEventFlag] = [
    .none,
    .lbutton,
    .rbutton,
    .shift,
    .control,
    .mbutton,
    .xbutton1,
    .xbutton2,
  ]
}

#endif  // swift(>=4.2)

enum Agora_Pb_Rctrl_KeyboardEventType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case keyboardEventUnknown // = 0
  case keyboardEventKeyDown // = 1
  case keyboardEventKeyUp // = 2
  case keyboardEventKeyChar // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .keyboardEventUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyboardEventUnknown
    case 1: self = .keyboardEventKeyDown
    case 2: self = .keyboardEventKeyUp
    case 3: self = .keyboardEventKeyChar
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .keyboardEventUnknown: return 0
    case .keyboardEventKeyDown: return 1
    case .keyboardEventKeyUp: return 2
    case .keyboardEventKeyChar: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Agora_Pb_Rctrl_KeyboardEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Agora_Pb_Rctrl_KeyboardEventType] = [
    .keyboardEventUnknown,
    .keyboardEventKeyDown,
    .keyboardEventKeyUp,
    .keyboardEventKeyChar,
  ]
}

#endif  // swift(>=4.2)

struct Agora_Pb_Rctrl_RctrlMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Agora_Pb_Rctrl_MsgType = .unknownType

  var version: Int32 = 0

  var msgID: UInt32 = 0

  var timestamp: UInt64 = 0

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Agora_Pb_Rctrl_RctrlMsges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msges: [Agora_Pb_Rctrl_RctrlMsg] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// extData for MOUSE_EVENT_WHEEL, high 16 bits is delta, low 16 bits is state
/// extData low 16 bits is combined key state
struct Agora_Pb_Rctrl_MouseEventMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mouseEvent: UInt32 = 0

  var x: Int32 = 0

  var y: Int32 = 0

  var extData: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// vkey is vitual key code, 
/// see https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
/// state is key repeat count, scan code and flags, see https://learn.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
/// and see: https://learn.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input#keystroke-message-flags
/// vkey and state may be generated by external tools, and mapped with mobile-phone app button, and configed in DB
struct Agora_Pb_Rctrl_KeyboardEventMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyboardEvent: UInt32 = 0

  var vkey: UInt32 = 0

  var state: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Agora_Pb_Rctrl_MsgType: @unchecked Sendable {}
extension Agora_Pb_Rctrl_MouseEventType: @unchecked Sendable {}
extension Agora_Pb_Rctrl_MouseEventFlag: @unchecked Sendable {}
extension Agora_Pb_Rctrl_KeyboardEventType: @unchecked Sendable {}
extension Agora_Pb_Rctrl_RctrlMsg: @unchecked Sendable {}
extension Agora_Pb_Rctrl_RctrlMsges: @unchecked Sendable {}
extension Agora_Pb_Rctrl_MouseEventMsg: @unchecked Sendable {}
extension Agora_Pb_Rctrl_KeyboardEventMsg: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "agora.pb.rctrl"

extension Agora_Pb_Rctrl_MsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1001: .same(proto: "MOUSE_EVENT_TYPE"),
    1002: .same(proto: "KEYBOARD_EVENT_TYPE"),
  ]
}

extension Agora_Pb_Rctrl_MouseEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOUSE_EVENT_UNKNOWN"),
    1: .same(proto: "MOUSE_EVENT_MOVE"),
    2: .same(proto: "MOUSE_EVENT_LBUTTON_DOWN"),
    3: .same(proto: "MOUSE_EVENT_LBUTTON_UP"),
    4: .same(proto: "MOUSE_EVENT_RBUTTON_DOWN"),
    5: .same(proto: "MOUSE_EVENT_RBUTTON_UP"),
    6: .same(proto: "MOUSE_EVENT_MBUTTON_DOWN"),
    7: .same(proto: "MOUSE_EVENT_MBUTTON_UP"),
    8: .same(proto: "MOUSE_EVENT_WHEEL"),
    9: .same(proto: "MOUSE_EVENT_XBUTTON_DOWN"),
    10: .same(proto: "MOUSE_EVENT_XBUTTON_UP"),
    11: .same(proto: "MOUSE_EVENT_HWHEEL"),
  ]
}

extension Agora_Pb_Rctrl_MouseEventFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOUSE_EVENT_FLAG_NONE"),
    1: .same(proto: "MOUSE_EVENT_FLAG_LBUTTON"),
    2: .same(proto: "MOUSE_EVENT_FLAG_RBUTTON"),
    4: .same(proto: "MOUSE_EVENT_FLAG_SHIFT"),
    8: .same(proto: "MOUSE_EVENT_FLAG_CONTROL"),
    16: .same(proto: "MOUSE_EVENT_FLAG_MBUTTON"),
    32: .same(proto: "MOUSE_EVENT_FLAG_XBUTTON1"),
    64: .same(proto: "MOUSE_EVENT_FLAG_XBUTTON2"),
  ]
}

extension Agora_Pb_Rctrl_KeyboardEventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEYBOARD_EVENT_UNKNOWN"),
    1: .same(proto: "KEYBOARD_EVENT_KEY_DOWN"),
    2: .same(proto: "KEYBOARD_EVENT_KEY_UP"),
    3: .same(proto: "KEYBOARD_EVENT_KEY_CHAR"),
  ]
}

extension Agora_Pb_Rctrl_RctrlMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RctrlMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
    3: .same(proto: "msgId"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.msgID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.msgID != 0 {
      try visitor.visitSingularUInt32Field(value: self.msgID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Agora_Pb_Rctrl_RctrlMsg, rhs: Agora_Pb_Rctrl_RctrlMsg) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Agora_Pb_Rctrl_RctrlMsges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RctrlMsges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.msges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Agora_Pb_Rctrl_RctrlMsges, rhs: Agora_Pb_Rctrl_RctrlMsges) -> Bool {
    if lhs.msges != rhs.msges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Agora_Pb_Rctrl_MouseEventMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MouseEventMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mouseEvent"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "extData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.mouseEvent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.extData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mouseEvent != 0 {
      try visitor.visitSingularUInt32Field(value: self.mouseEvent, fieldNumber: 1)
    }
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 2)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 3)
    }
    if self.extData != 0 {
      try visitor.visitSingularInt32Field(value: self.extData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Agora_Pb_Rctrl_MouseEventMsg, rhs: Agora_Pb_Rctrl_MouseEventMsg) -> Bool {
    if lhs.mouseEvent != rhs.mouseEvent {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.extData != rhs.extData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Agora_Pb_Rctrl_KeyboardEventMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyboardEventMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyboardEvent"),
    2: .same(proto: "vkey"),
    3: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.keyboardEvent) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.vkey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyboardEvent != 0 {
      try visitor.visitSingularUInt32Field(value: self.keyboardEvent, fieldNumber: 1)
    }
    if self.vkey != 0 {
      try visitor.visitSingularUInt32Field(value: self.vkey, fieldNumber: 2)
    }
    if self.state != 0 {
      try visitor.visitSingularUInt32Field(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Agora_Pb_Rctrl_KeyboardEventMsg, rhs: Agora_Pb_Rctrl_KeyboardEventMsg) -> Bool {
    if lhs.keyboardEvent != rhs.keyboardEvent {return false}
    if lhs.vkey != rhs.vkey {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
